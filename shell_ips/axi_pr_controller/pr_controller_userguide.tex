\documentclass{report}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage[bitheight=10ex]{bytefield}
\usepackage{color}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{float}
\definecolor{lightgray}{gray}{0.8}
\title{AXI PR Controller v1.0 User Guide}
\author{Daniel Ly-Ma}
\pagestyle{fancy}
\lfoot{AXI PR Controller v1.0 User Guide}
\rfoot{Page \thepage}
\begin{document}
\maketitle
\section*{Overview}
The AXI PR Controller is designed to efficiently program partial bitstreams that are stored in offchip memory and to readback partial reconfigurable regions on the FPGA back to offchip memory. It is to be used with an embedded processing system using the AXI interface such as the MicroBlaze and ARM processor. It supports the 7series, Ultrascale and Ultrascale+ families of chips.
\section*{Design Information}
These are some basic steps to use the controller in your design. 
\begin{enumerate}
	\item Make sure that you select the correct family in the IP configuration window for the controller. 
	\item Connect the m\_axi bus to your offchip memory where the partial bitstream will be stored.
	\item Connect the s\_axi\_ctrl bus to the MicroBlaze or ARM.
	\item If using interrupts, connect the done\_interrupt pin to the MicroBlaze or ARM.
\end{enumerate}
\subsection*{Partial Bitstream Format}
\textbf{WARNING}: The *.bit partial bitstreams generated by Vivado cannot be used directly with the controller. They must be converted to *.bin file to strip out the header. To do this, use the follow command in the Vivado tcl console on your partial bitstream: 
\begin{lstlisting}
write_cfgmem -format BIN -interface SMAPx32 -disablebitswap 
-loadbit "up 0x0 <partial_bitfile>"
\end{lstlisting}
\subsection*{CTRL (Control Register - Offset 00h)}
%\center
\begin{bytefield}[bitwidth=\textwidth/32, bitformatting={\large\bfseries},boxformatting={\Large\centering}, endianness=big]{32}
	\bitheader{0,7,8, 31}\\
	\bitbox{24}{\color{lightgray}\rule{\width}{\height}} & \bitbox{8}{Opcode} \\
\end{bytefield}

\begin{table}[H]
    \centering
    \caption{CTRL Register Description}
    \label{my-label}
    \begin{tabular}{|l|l|l|l|p{.3\textwidth}|}
        \hline
        \textbf{Bits} & \textbf{Field Name} & \textbf{Default Value} & \textbf{Access Type} & \textbf{Description} \\ \hline
            31 to 8  &     Reserved            &   0                     & RO                     & Writing to these bits has no effect.                      \\ \hline
            7 to 0 &       Opcode              & 0                       & R/W                     & Controls whether it is a write or read operation. Set to 0 to write a bitstream to the ICAP and 1 to read bits from the ICAP.  \begin{itemize}
                \item 0 = Write to ICAP
                \item 1 = Read from ICAP
            \end{itemize}\\ \hline
    \end{tabular}
\end{table}

\subsection*{BA\_MSB (Base Address (MSB) Register - Offset 04h)}
\begin{bytefield}[bitwidth=\textwidth/32, bitformatting={\large\bfseries},boxformatting={\Large\centering}, endianness=big]{32}
	\bitheader{0,7,8, 31}\\
	\bitbox{24}{\color{lightgray}\rule{\width}{\height}} & \bitbox{8}{Base Address (MSB)} \\
\end{bytefield}

\begin{table}[H]
    \centering
    \caption{BASE\_MSB Register Description}
    \label{my-label}
    \begin{tabular}{|l|l|l|l|p{.3\textwidth}|}
        \hline
        \textbf{Bits} & \textbf{Field Name} & \textbf{Default Value} & \textbf{Access Type} & \textbf{Description} \\ \hline
            31 to 8  &     Reserved                &   0                     & RO                     & Writing to these bits has no effect.                      \\ \hline
        7 to 0 &       Base Address (MSB)              & 0                       & R/W                     & If write operation,indicates the MSB 8 bits of the source address of the partial bitstream. If read operation, indicates the MSB 8 bits of the destination address to store readback bitstream\\ \hline
    \end{tabular}
\end{table}

\subsection*{BA (Base Address Register - Offset 08h)}
\begin{bytefield}[bitwidth=\textwidth/32, bitformatting={\large\bfseries},boxformatting={\Large\centering}, endianness=big]{32}
	\bitheader{0, 31}\\
	\bitbox{32}{Base Address} \\
\end{bytefield}

\begin{table}[H]
    \centering
    \caption{BA Register Description}
    \label{my-label}
    \begin{tabular}{|l|l|l|l|p{.3\textwidth}|}
        \hline
        \textbf{Bits} & \textbf{Field Name} & \textbf{Default Value} & \textbf{Access Type} & \textbf{Description} \\ \hline
        31 to 0 &       Base Address              & 0                       & R/W                     & If write operation,indicates the lower 32 bits of source address of the partial bitstream. If read operation, indicates the lower 32 bits of the destination address to store readback bitstream\\ \hline
    \end{tabular}
\end{table}

\subsection*{BIT\_SIZE (Bitstream Size Register - Offset 0Ch)}
\begin{bytefield}[bitwidth=\textwidth/32, bitformatting={\large\bfseries},boxformatting={\Large\centering}, endianness=big]{32}
	\bitheader{0, 31}\\
	\bitbox{32}{Bitstream Size} \\
\end{bytefield}

\begin{table}[H]
    \centering
    \caption{BIT\_SIZE Register Description}
    \label{my-label}
    \begin{tabular}{|l|l|l|l|p{.3\textwidth}|}
        \hline
        \textbf{Bits} & \textbf{Field Name} & \textbf{Default Value} & \textbf{Access Type} & \textbf{Description} \\ \hline
        31 to 0 &       Base Address              & 0                       & R/W                     & If write operation, indicates the size (bytes) of the partial bitstream to be written. If read operation, indicates the size (bytes) of the readback to save from the ICAP. The CTRL, and BA registers should be written before writing to the BIT\_SIZE register since writing to this register will create a task and put it on the task queue. Writes to this register will be ignored while the controller is busy. \\ \hline
    \end{tabular}
\end{table}

\subsection*{NUM\_BIT (Bitstream Count Register - Offset 10h)}
\begin{bytefield}[bitwidth=\textwidth/32, bitformatting={\large\bfseries},boxformatting={\Large\centering}, endianness=big]{32}
	\bitheader{0, 31}\\
	\bitbox{32}{Count}
\end{bytefield}

\begin{table}[H]
    \centering
    \caption{NUM\_BIT Register Description}
    \label{my-label}
    \begin{tabular}{|l|l|l|l|p{.3\textwidth}|}
        \hline
        \textbf{Bits} & \textbf{Field Name} & \textbf{Default Value} & \textbf{Access Type} & \textbf{Description} \\ \hline
        31 to 0 &       Base Address              & 0                       & R/W                     & Indicates how many operations that were queued. Must match the number of times BIT\_SIZE was written to. Writing to this register will cause the controller to begin processing the tasks on the queue. Writes to this register will be ignored while the controller is busy.\\ \hline
    \end{tabular}
\end{table}

\subsection*{STATUS (Status Register - Offset 14h)}
\begin{bytefield}[bitwidth=\textwidth/32, bitformatting={\large\bfseries},boxformatting={\Large\centering}, endianness=big]{32}
	\bitheader{0,1,2,3,4,31}\\
	\bitbox{28}{\color{lightgray}\rule{\width}{\height}} & \bitbox{1}{\rotatebox{90}{DMErr}} & \bitbox{1}{\rotatebox{90}{PRErr}} & \bitbox{1}{\rotatebox{90}{Busy}} & \bitbox{1}{\rotatebox{90} {Done}} 
\end{bytefield}

\begin{table}[H]
    \centering
    \caption{STATUS Register Description}
    \label{my-label}
    \begin{tabular}{|l|l|l|l|p{.3\textwidth}|}
        \hline
        \textbf{Bits} & \textbf{Field Name} & \textbf{Default Value} & \textbf{Access Type} & \textbf{Description} \\ \hline
            31 to 4  &     Reserved                &   0                     & RO                     & Writing to these bits has no effect.                      \\ \hline
            3 &       DMErr              & 0                       & RO                     & Indicates an error with the datamover \\ \hline
            2 &       PRErr              & 0                       & RO                     & Indicates an error with the ICAP      \\ \hline
            1 &       Busy               & 0                       & RO                     & Indicates that the controller is busy  \\ \hline
            0 &       Done              & 0                       & R/W                     & Indicates that the controller has finished processing the all the tasks on the queue. Must be cleared before new tasks can be queued. Writing a 1 to this bit will clear it. \\ \hline
    \end{tabular}
\end{table}
\section*{Programming Sequence}
\subsection*{Writing a Partial Bitstream}
These steps will show you how to use the controller to write a partial bitstream to the FPGA. 
\begin{enumerate}
	\item Set the task to be in write mode by writing 0 to the Opcode field in CTRL (CTRL.Opcode = 0).
	\item Point the task to the base address of the partial bitstream in DDR memory by writing the appropriate address to BA and BA\_MSB.
	\item Write the size of the partial bitstream in bytes to the BIT\_SIZE register. This will add the task to the queue.
	\item Write 1 to the NUM\_BIT register (NUM\_BIT.Count = 1). This will tell the controller to start processing tasks on the queue.
	\item Either poll the STATUS.Done bit or wait for the controller to generate an interrupt.
	\item Clear the interrupt and STATUS.Done bit by writing a 1 to STATUS.Done (STATUS.Done = 1).
	\item Ready for another transfer. Go back to step 1.
\end{enumerate}

\subsection*{Writing Multiple Partial Bitstreams}
These steps will show you how to use the controller to write multiple partial bitstream to the FPGA. 
\begin{enumerate}
	\item Set the task to be in write mode by writing 0 to the Opcode field in CTRL (CTRL.Opcode = 0).
	\item Point the task to the base address of the partial bitstream in DDR memory by writing the appropriate address to BA and BA\_MSB.
	\item Write the size of the partial bitstream in bytes to the BIT\_SIZE register. This will add the task to the queue.
	\item Repeat steps 1 - 3 for all of the partial bitstreams you want to program.
	\item Write the number of tasks that were enqueued to the NUM\_BIT register. This will tell the controller to start processing tasks on the queue.
	\item Either poll the STATUS.Done bit or wait for the controller to generate an interrupt.
	\item Clear the interrupt and STATUS.Done bit by writing a 1 to STATUS.Done (STATUS.Done = 1).
	\item Ready for another transfer. Go back to step 1.
\end{enumerate}
\subsection*{Readback}
These steps will show you how to readback the bits in a partial reconfigurable region on the FPGA. 
\begin{enumerate}
	\item Put the ICAP into readback state by enqueuing a write task for your first stage readback partial bitstream using the steps outlined above.
	\item Set a new task to be in read mode by writing 1 to the Opcode field in CTRL (CTRL.Opcode = 1).
	\item Point the task to the base address of where you want to store the readback data in DDR memory by writing the appropriate address to BA and BA\_MSB.
	\item Write the size of the readback data in bytes to the BIT\_SIZE register. This will add the task to the queue.
	\item Take the ICAP out of readback state by enqueuing a write task for your second stage readback partial bitstream using the steps outlined above.
	\item Write 3 to the NUM\_BIT register (NUM\_BIT.Count = 1). This will tell the controller to start processing tasks on the queue.
	\item Either poll the STATUS.Done bit or wait for the controller to generate an interrupt.
	\item Clear the interrupt and STATUS.Done bit by writing a 1 to STATUS.Done (STATUS.Done = 1).
	\item Ready for another transfer. Go back to step 1.
\end{enumerate}
\end{document}
